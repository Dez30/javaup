---
slug: /java/base/summary-7
title: 基础面经总结-7
---

# 基础面经总结-7

## String 类详解

### String、StringBuffer 与 StringBuilder

#### 可变性差异

**String**:不可变,每次修改都创建新对象
```java
String str = "Hello";
str = str + " World";  // 创建新对象,原对象不变
```

String 不可变的原因:
```java
public final class String {  // final 类不能被继承
    private final char[] value;  // final 数组不能指向新数组
    // 没有提供修改数组内容的方法
}
```

**StringBuilder/StringBuffer**:可变,修改在原对象上进行
```java
abstract class AbstractStringBuilder {
    char[] value;  // 非 final,可以修改
    
    public AbstractStringBuilder append(String str) {
        // 在原数组上修改
        return this;
    }
}
```

#### 线程安全差异

- **String**:不可变,天然线程安全
- **StringBuffer**:方法加 `synchronized`,线程安全
- **StringBuilder**:无同步机制,非线程安全

```java
// StringBuffer 的同步方法
public synchronized StringBuffer append(String str) {
    super.append(str);
    return this;
}
```

#### 性能对比

```java
// 性能测试:拼接 10000 次
long start = System.currentTimeMillis();

// String: 每次创建新对象 (最慢)
String s = "";
for (int i = 0; i < 10000; i++) {
    s += i;
}

// StringBuffer: 有同步开销 (中等)
StringBuffer sb = new StringBuffer();
for (int i = 0; i < 10000; i++) {
    sb.append(i);
}

// StringBuilder: 无同步开销 (最快)
StringBuilder sbd = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sbd.append(i);
}
```

**使用建议**:
- 少量操作:用 `String`
- 单线程大量操作:用 `StringBuilder`
- 多线程大量操作:用 `StringBuffer`

### String 为什么不可变?

**表层原因**:
```java
public final class String {
    private final char[] value;  // 数组被 final 修饰
}
```

**深层原因**:
1. `value` 数组被 `final` 修饰且私有,不能重新赋值
2. String 类被 `final` 修饰,不能被继承,避免子类破坏
3. String 类没有提供修改数组内容的方法

> **Java 9 变化**:底层由 `char[]` 改为 `byte[]`,节省内存。Latin-1 字符集内的字符用 1 字节存储,否则用 2 字节(UTF-16)。

### 字符串拼接用 + 还是 StringBuilder?

**简单拼接**:编译器会优化
```java
String s = "Hello" + " " + "World";
// 编译器优化为:
String s = "Hello World";
```

**循环拼接**:编译器无法优化
```java
// 错误写法:每次循环创建新的 StringBuilder
String s = "";
for (int i = 0; i < 1000; i++) {
    s += i;  // 编译为: s = new StringBuilder(s).append(i).toString();
}

// 正确写法:复用同一个 StringBuilder
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);
}
String s = sb.toString();
```

**JDK 9+ 优化**:使用 `makeConcatWithConstants()` 动态方法,但循环中仍建议手动用 StringBuilder。

### 字符串常量池机制

字符串常量池位于堆中,用于存储字符串字面量,避免重复创建:

```java
String s1 = "Java";  // 在常量池创建 "Java"
String s2 = "Java";  // 复用常量池中的 "Java"
System.out.println(s1 == s2);  // true

String s3 = new String("Java");  // 在堆中创建新对象
System.out.println(s1 == s3);  // false
```

### String s = new String("abc") 创建几个对象?

**情况1:常量池中无 "abc"**
- 创建 2 个对象
    1. 常量池中创建 "abc"(由 `ldc` 指令触发)
    2. 堆中创建 String 对象(由 `new` 触发)

**情况2:常量池中已有 "abc"**
- 创建 1 个对象
    1. 堆中创建 String 对象,引用常量池中的 "abc"

**字节码分析**:
```java
String s = new String("abc");

// 对应字节码:
0 new #2 <java/lang/String>        // 在堆中分配内存
3 dup                               // 复制引用
4 ldc #3 <abc>                      // 加载常量池中的 "abc"
6 invokespecial #4 <init>           // 调用构造方法
9 astore_1                          // 存入局部变量表
```

### String#intern() 方法

`intern()` 方法确保字符串在常量池中的唯一性:

```java
String s1 = "Hello";
String s2 = new String("Hello");
String s3 = s2.intern();

System.out.println(s1 == s2);  // false (s2 在堆中)
System.out.println(s1 == s3);  // true (s3 指向常量池)
System.out.println(s2 == s3);  // false
```

**工作原理**:
1. 如果常量池中已有相同内容的字符串,返回常量池中的引用
2. 如果常量池中没有,将当前字符串添加到常量池并返回引用

### String 拼接的底层机制

```java
String s1 = "Hello";
String s2 = "World";  
String s3 = "HelloWorld";
String s4 = s1 + s2;
String s5 = "Hello" + "World";

System.out.println(s3 == s4);  // false
System.out.println(s3 == s5);  // true
```

**原因**:

**编译期确定的拼接**:编译器进行常量折叠优化
```java
String s5 = "Hello" + "World";
// 编译器优化为:
String s5 = "HelloWorld";
```

**运行期拼接**:使用 StringBuilder
```java
String s4 = s1 + s2;
// 编译为:
String s4 = new StringBuilder().append(s1).append(s2).toString();
```

**final 变量的拼接**:可以被编译器优化
```java
final String s1 = "Hello";
final String s2 = "World";
String s3 = "HelloWorld";
String s4 = s1 + s2;

System.out.println(s3 == s4);  // true (编译期优化)
```

**但如果 final 变量的值是运行时确定的,仍然无法优化**:
```java
final String s1 = "Hello";
final String s2 = getString();  // 运行时确定
String s3 = "HelloWorld";
String s4 = s1 + s2;

System.out.println(s3 == s4);  // false
```